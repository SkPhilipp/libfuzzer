# EffortGames libfuzzer

EffortGames' libfuzzer is a C# library containing utilities to conveniently automate the fuzzing of C# classes. By fuzzing and checking for behaviour, we can find bugs in old and new code, cover new branches and functionalities without necessarily having to introduce new tests.

## What is fuzzing?

Fuzzing is a technique to find bugs and verify program behaviour by generating random inputs and checking whether the program behaves as expected, commonly after an input or after all inputs. When testing a calculator for example, fuzzing it could be as simple as pressing many buttons at random and ensuring that it doesn't crash or otherwise fail. One could also apply the same inputs against two separate calculators, and verify that if they produce the same results. Do note that tests which apply fuzzing do not usually verify individual functionalities (i.e. checking whether 1 + 1 on a calculator equals 2).

Moreover, fuzzing generates a lot of inputs and may take a long time to complete. You can specify manually how many iterations the fuzzer should attempt.

## Getting started

Fuzzing in EffortGames' libfuzzer is performed by creatinga blueprint and passing this to the fuzzer. Blueprints specify which actions a fuzzer can perform, how many and in which order. Using the calculator example, a fuzz test could look like this:

```c#
[Test]
public void FuzzCalculator()
{
    // specifies a blueprint in which "Add" and "Subtract" may appear 0 to 10 times,
    //                                 followed by "Multiply" or "Divide" 0 to 10 times,
    //                                 followed by "AssertFinite" once.
    var blueprint = new FuzzerBlueprint<CalculatorContext>()
        .Phase(0, 10)
        .Step("Add", (context, seed) => context.Add(seed))
        .Step("Subtract", (context, seed) => context.Subtract(seed))
        .Phase(0, 10)
        .Step("Multiply", (context, seed) => context.Multiply(seed))
        .Step("Divide", (context, seed) => context.Divide(seed))
        .Phase(1, 1)
        .Step("AssertFinite", (context, seed) => context.AssertFinite(seed));

    // the fuzzer is instructed to re-generate and execute a plan 1000 times over, according to the rules of the blueprint.
    // each plan is performed against a new "CalculatorContext".
    var fuzzer = new Fuzzer<CalculatorContext>(() => new CalculatorContext());
    fuzzer.Fuzz(blueprint, 1000);
}
```

See [./fuzzer.tests/CalculatorFuzzerTests.cs](./fuzzer.tests/CalculatorFuzzerTests.cs) for the complete example.

## Features

### Replays

When an exception occurs during fuzzing, the fuzzer will re-throw it as a `FuzzerException` which can be printed to displays the error-reproducing plan as C#-ish pseudocode. When provided with the correct naming configuration, these can often be pasted them into your fuzzing test to manually debug why the exception occured. Below is a real (un-simplified) example;

```c#
fuzzer.Replay(context => {
    context.Add(0.9664580677479776);
    context.Add(0.28429890949479253);
    context.Subtract(0.5269592267120998);
    context.Subtract(0.09305505458873467);
    context.Subtract(0.22555044397038895);
    context.Subtract(0.22129066438474257);
    context.Multiply(0.7851263353531838);
    context.Multiply(0.7049641379643996);
    context.Multiply(0.27297008562505715);
    context.Multiply(0.7952038886934537);
    context.Divide(0.35190024708951834);
    // This calculator is broken
    context.AssertFinite(0.6865309345007552);
});
```

### Simplification

Continuing with the example above, the fuzzer has found a divide by zero "exception". We known that to divide by zero, only `Divide` is required. `Add`, `Subtract` and `Multiply` are not needed to reproduce it. Plans generated by the fuzzer can be lengthy, and its steps complex. To reduce complexity in debugging, EffortGames' libfuzzer performs simplification out of the box. Simplification reduces a plan known to reproduce an exception to its most minimal form. When applying the simplification to the plan in the previous section's replay, the result is:

```c#
fuzzer.Replay(context => {
    context.Divide(0);
    // This calculator is broken
    context.AssertFinite(0);
    
});
```

As is immediately visible, all but one steps were automatically removed as they played no role in the exception occurring. Even the seed was simplified to zero, indicating that the exception is likely reproducible with any value.

By default, simplification will try to remove steps (where allowed by the blueprint's rules) and verify that an exception still occurs. When it does, the process is repeated using this new simplified plan until no further simplifications can be applied. Moreover, seed values can also be simplified (i.e. to zero) to indicate an error likely does not depend on a step's seed.

See [./fuzzer.tests/CalculatorBlueprints.cs](./fuzzer.tests/CalculatorBlueprints.cs) for configuration examples.
